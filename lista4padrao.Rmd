---
title: 'Lista 4: Teoria de Vis'
author: "João Vitor Freitas Sousa"
date: "05/05/2020"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE,
                      fig.retina = 2,
                      tidy.opts=list(width.cutoff = 120),
                      options(width = 120, scipen = 1000))
library(tidyverse)
library(lubridate)
library(ggmap)
library(ggrepel)
library(gridExtra)
library(pander)
library(xlsx)
library(devtools)
library(RCurl)
library(httr)
library(reshape)
library(gapminder)
library(dplyr)
library(gganimate)
library(plotly)
library(gifski)
library(grid)
```

# Problema 1: The Economist

Crie o último gráfico do link https://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html. Este é um gráfico que apresenta uma relação entre o IDH x IPC entre diversos países.

**Resposta:**

Vamos começar importando os dados baixados no link citado acima e vamos plotar de forma basica os dados que vamos representar no gráfico final utilizando `ggplot`.

```{r, message=FALSE}
dat <- read_csv("./1/EconomistData.csv")

pc1 <- ggplot(dat, aes(x = CPI, y = HDI, color = Region))
pc1 + geom_point()
```

Vamos adicionar então a linha de tendência presente no gráfico original utilizando o `geom_smooth`.

```{r}
pc2 <- pc1 +
  geom_smooth(mapping = aes(linetype = "r2"),
              method = "lm",
              formula = y ~ x + log(x), se = FALSE,
              color = "red")
pc2 + geom_point()
```

Observando o gráfico original percebe-se que tal usa "pontos furados", vamos então alterar a forma que utilizamos no `geom_point`.

```{r}
pc2 +
  geom_point(shape = 1, size = 4)
```

Consertando o tamanho e a espessura das circunferências:

```{r}
(pc3 <- pc2 + geom_point(shape = 1, size = 2.5, stroke = 1.25))
```

Agora vamos trabalhar nas labels de alguns pontos, os mesmos que aparecem no gráfico original. Na base de dados que temos esses dados não estão separados, vamos então separá-los manualmente:

```{r}
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
                   "Afghanistan", "Congo", "Greece", "Argentina", "Brazil",
                   "India", "Italy", "China", "South Africa", "Spane",
                   "Botswana", "Cape Verde", "Bhutan", "Rwanda", "France",
                   "United States", "Germany", "Britain", "Barbados", "Norway", "Japan",
                   "New Zealand", "Singapore")
```

Aplicando `geom_text`, vamos adicionar as labels:

```{r}
(pc4 <- pc3 +
  geom_text(aes(label = Country),
            color = "gray20",
            data = filter(dat, Country %in% pointsToLabel)))
```


Algumas labels estão "camufladas" por outros pontos ou por outras labels, vamos então utilizar a biblioteca `ggrepel` para gerar as labels:

```{r}
(pc4 <- pc3 +
   geom_text_repel(aes(label = Country),
                   color = "gray20",
                   data = filter(dat, Country %in% pointsToLabel),
                   force = 10))
```

Vamos agora modificar as legendas e a escala de cor dos pontos.
Começamos renomeando as regiões que aparecem para que fiquem como no gráfico original:

```{r}
dat$Region <- factor(dat$Region,
                     levels = c("EU W. Europe",
                                "Americas",
                                "Asia Pacific",
                                "East EU Cemt Asia",
                                "MENA",
                                "SSA"),
                     labels = c("OECD",
                                "Americas",
                                "Asia &\nOceania",
                                "Central &\nEastern Europe",
                                "Middle East &\nnorth Africa",
                                "Sub-Saharan\nAfrica"))

```

Aplicando os novos dados ao gráfico e plotando novamente:

```{r}
pc4$data <- dat
pc4
```

Vamos então adicionar o título modificar os eixos utilizando o sistema de  `scales` do ggplot2 para cada eixo e para as cores.

```{r}
(pc5 <- pc4 +
  scale_x_continuous(name = "Corruption Perceptions Index, 2011 (10=least corrupt)",
                     limits = c(.9, 10.5),
                     breaks = 1:10) +
  scale_y_continuous(name = "Human Development Index, 2011 (1=Best)",
                     limits = c(0.2, 1.0),
                     breaks = seq(0.2, 1.0, by = 0.1)) +
  scale_color_manual(name = "",
                     values = c("#24576D",
                                "#099DD7",
                                "#28AADC",
                                "#248E84",
                                "#F2583F",
                                "#96503F")) +
  ggtitle("Corruption and Human development"))

```

Vamos fazer agora alguns ajustes no "tema" do gráfico, criando na realidade um tema básico e fazendo as alterações desejadas manualmente.
Vamos mudar a posição da legenda, mudar a maneira como o grid de fundo que representa os eixos é representado e a posição do título.

```{r}
library(grid)
(pc6 <- pc5 +
  theme_minimal()+
  theme(text = element_text(color = "gray20"),
        legend.position = c("top"),
        legend.direction = "horizontal",
        legend.justification = 0.1,
        legend.text = element_text(size = 11, color = "gray10"),
        axis.text = element_text(face = "italic"),
        axis.title.x = element_text(vjust = -1),
        axis.title.y = element_text(vjust = 2),
        axis.ticks.y = element_blank(),
        axis.line = element_line(color = "gray40", size = 0.5),
        axis.line.y = element_blank(),
        panel.grid.major = element_line(color = "gray50", size = 0.5),
        panel.grid.major.x = element_blank()
        ))
```

Agora nos falta adicionar a fonte e mudar o modelo utilizado na formação da linha de tendência.
Primeiro adicionamos a fonte:

```{r}
(pc7 <- pc6 +
   labs(caption="Sources: Transparency International; UN Human Development Report"))
```


Aqui criamos o novo modelo e a forma com a qual ele aparecerá na legenda e plotamos o gráfico já com o modelo.

```{r, fig.width=9, fig.height=6}
mR2 <- summary(lm(HDI ~ CPI + log(CPI), data = dat))$r.squared
mR2 <- paste0(format(mR2, digits = 2), "%")
(pc8 <- pc7 +
    scale_linetype(name = "",
                 breaks = "r2",
                 labels = list(bquote(R^2==.(mR2))),
                 guide = guide_legend(override.aes = list(linetype = 1, size = 2, color = "red"), order=2)))
```

Aqui então temos a união dos códigos gerados durante o processo, então o código final:

```{r, fig.width=14, fig.height=10, warning=FALSE}
p <- ggplot(dat,
            mapping = aes(x = CPI, y = HDI)) +
  geom_smooth(mapping = aes(linetype = "r2"),
              method = "lm",
              formula = y ~ x + log(x), se = FALSE,
              color = "red") +
  geom_point(mapping = aes(color = Region),
             shape = 1,
             size = 4,
             stroke = 1.5) +
  geom_text_repel(mapping = aes(label = Country, alpha = labels),
                  color = "gray20",
                  data = transform(dat,
                                   labels = Country %in% c("Russia",
                                                           "Venezuela",
                                                           "Iraq",
                                                           "Mayanmar",
                                                           "Sudan",
                                                           "Afghanistan",
                                                           "Congo",
                                                           "Greece",
                                                           "Argentinia",
                                                           "Italy",
                                                           "Brazil",
                                                           "India",
                                                           "China",
                                                           "South Africa",
                                                           "Spain",
                                                           "Cape Verde",
                                                           "Bhutan",
                                                           "Rwanda",
                                                           "France",
                                                           "Botswana",
                                                           "France",
                                                           "US",
                                                           "Germany",
                                                           "Britain",
                                                           "Barbados",
                                                           "Japan",
                                                           "Norway",
                                                           "New Zealand",
                                                           "Sigapore"))) +
  scale_x_continuous(name = "Corruption Perception Index, 2011 (10=least corrupt)",
                     limits = c(1.0, 10.0),
                     breaks = 1:10) +
  scale_y_continuous(name = "Human Development Index, 2011 (1=best)",
                     limits = c(0.2, 1.0),
                     breaks = seq(0.2, 1.0, by = 0.1)) +
  scale_color_manual(name = "",
                     values = c("#24576D",
                                "#099DD7",
                                "#28AADC",
                                "#248E84",
                                "#F2583F",
                                "#96503F"),
                     guide = guide_legend(nrow = 1, order=1)) +
  scale_alpha_discrete(range = c(0, 1),
                       guide = FALSE) +
  scale_linetype(name = "",
                 breaks = "r2",
                 labels = list(bquote(R^2==.(mR2))),
                 guide = guide_legend(override.aes = list(linetype = 1, size = 2, color = "red"), order=2)) +
  ggtitle("Corruption and human development") +
  labs(caption="Sources: Transparency International; UN Human Development Report") +
  theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid = element_blank(),
        panel.grid.major.y = element_line(color = "gray"),
        text = element_text(color = "gray20"),
        axis.title.x = element_text(face="italic"),
        axis.title.y = element_text(face="italic"),
        legend.position = "top",
        legend.direction = "horizontal",
        legend.box = "horizontal",
        legend.text = element_text(size = 12),
        plot.caption = element_text(hjust=0),
        plot.title = element_text(size = 16, face = "bold"))
p
```

# Problema 2: Minard

Reproduza o gráfico de Minard que representa a jornada do lider político Napoleão ao levar seu exército para a Campanha Russa. O tutorial se encontra em [https://www.andrewheiss.com/blog/2017/08/10/exploring-minards-1812-plot-with-ggplot2/].

**Resposta:**

Começamos importando os dados baixados e já transformando as datas para o formato padrão do R.

```{r}
cities <- read.table("./2/cities.txt",
                     header = TRUE, stringsAsFactors = FALSE)

troops <- read.table("./2/troops.txt",
                     header = TRUE, stringsAsFactors = FALSE)

temps <- read.table("./2/temps.txt",
                    header = TRUE, stringsAsFactors = FALSE) %>%
  mutate(date = dmy(date))
```

Vamos começar com o gráfico de cima. Dentro da variável `troops` armazenamos os dados relativos ao caminhos traçados por cada grupo. Plotando esses caminhos com o `geom_path()`:

```{r,fig.width=10, fig.height=2.5}
ggplot(troops, aes(x = long, y = lat, group = group)) +
  geom_path()
```

Plotando agora com o diferenciando a quantidade de sobreviventes pela espessura da linha e a direção pela cor:

```{r, fig.width=10, fig.height=2.5}
ggplot(troops, aes(x = long, y = lat, group = group,
                   color = direction, size = survivors)) +
  geom_path(lineend = "round")
```

Vamos usar o `scale_size()` para transmitir melhor a quantidade de sobreviventes:

```{r, fig.width=10, fig.height=2.5}
ggplot(troops, aes(x = long, y = lat, group = group,
                   color = direction, size = survivors)) +
  geom_path(lineend = "round") +
  scale_size(range = c(0.5, 15))
```

Vamos remover a legendas e mudar as cores:

```{r, fig.width=10, fig.height=2.5}
ggplot(troops, aes(x = long, y = lat, group = group,
                   color = direction, size = survivors)) +
  geom_path(lineend = "round") +
  scale_size(range = c(0.5, 15)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  labs(x = NULL, y = NULL) +
  guides(color = FALSE, size = FALSE)
```

Vamos então adicionar as cidades nas quais as tropas passaram no gráfico com o `geom_point()`:

```{r, fig.width=10, fig.height=2.5}
ggplot() +
  geom_path(data = troops, aes(x = long, y = lat, group = group,
                               color = direction, size = survivors),
            lineend = "round") +
  geom_point(data = cities, aes(x = long, y = lat)) +
  geom_text(data = cities, aes(x = long, y = lat, label = city), vjust = 1.5) +
  scale_size(range = c(0.5, 15)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  labs(x = NULL, y = NULL) +
  guides(color = FALSE, size = FALSE)
```

Como os nomes de algumas das cidades ficou em cima da linha preta, vamos utilizar o `geom_textrepel()` para resolver esse problema:

```{r, fig.width=10, fig.height=2.5, warning=FALSE}
ggplot() +
  geom_path(data = troops, aes(x = long, y = lat, group = group,
                               color = direction, size = survivors),
            lineend = "round") +
  geom_point(data = cities, aes(x = long, y = lat),
             color = "#DC5B44") +
  geom_text_repel(data = cities, aes(x = long, y = lat, label = city),
                  color = "#DC5B44") +
  scale_size(range = c(0.5, 15)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  labs(x = NULL, y = NULL) +
  guides(color = FALSE, size = FALSE)
```

Vamos agora começar o processo de adicionar um mapa no gráfico, para isso temos que baixar a imagem de fundo:

```{r, message=FALSE}
march.1812.europe <- c(left = -13.10, bottom = 35.75, right = 41.04, top = 61.86)
march.1812.europe.map <- get_stamenmap(bbox = march.1812.europe, zoom = 5,
                                       maptype = "terrain", where = "cache")
march.1812.europe.map.wc <- get_stamenmap(bbox = march.1812.europe, zoom = 5,
                                          maptype = "watercolor", where = "cache")
```

Usando `ggmap` vamos adicionar o mapa de fundo:

```{r, fig.width=10, fig.height=6}
ggmap(march.1812.europe.map.wc) +
  geom_path(data = troops, aes(x = long, y = lat, group = group,
                               color = direction, size = survivors),
            lineend = "round") +
  scale_size(range = c(0.5, 5)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  guides(color = FALSE, size = FALSE) +
  theme_nothing()
```

Vamos agora dar um zoom no mapa para a região que queremos, mudar o tipo de mapa para "mapa de terreno" e então adicionar o resto dos elementos que já tinhamos:

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=4}
march.1812.ne.europe <- c(left = 23.5, bottom = 53.4, right = 38.1, top = 56.3)

march.1812.ne.europe.map <- get_stamenmap(bbox = march.1812.ne.europe, zoom = 8,
                                          maptype = "terrain-background", where = "cache")

march.1812.plot <- ggmap(march.1812.ne.europe.map) +
  geom_path(data = troops, aes(x = long, y = lat, group = group,
                               color = direction, size = survivors),
            lineend = "round") +
  geom_point(data = cities, aes(x = long, y = lat),
             color = "#DC5B44") +
  geom_text_repel(data = cities, aes(x = long, y = lat, label = city),
                  color = "#DC5B44") +
  scale_size(range = c(0.5, 10)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  guides(color = FALSE, size = FALSE) +
  theme_nothing()

march.1812.plot
```

Temos então a parte superior do gráfico final, vamos ao gráfico de temperaturas.

Podemos facilmente gerá-lo com `geom_line()`:

```{r, fig.width=10, fig.height=4}
ggplot(data = temps, aes(x = long, y = temp)) +
  geom_line() +
  geom_text(aes(label = temp), vjust = 1.5)
```

Melhorando as labels, removendo o grid vertical, movendo o eixo y para a direita e removendo as descrições do eixo x:

```{r, fig.width=10, fig.height=4, warning=FALSE}
temps.nice <- temps %>%
  mutate(nice.label = paste0(temp, "°, ", month, ". ", day))

temps.1812.plot <- ggplot(data = temps.nice, aes(x = long, y = temp)) +
  geom_line() +
  geom_label(aes(label = nice.label),
             size = 2.5) +
  labs(x = NULL, y = "° Celsius") +
  scale_x_continuous(limits = ggplot_build(march.1812.plot)$layout$panel_ranges[[1]]$x.range) +
  scale_y_continuous(position = "right") +
  coord_cartesian(ylim = c(-35, 5)) +  # Add some space above/below
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks = element_blank(),
        panel.border = element_blank())

temps.1812.plot
```

Tendo o gráfico de temperatura, vamos juntar os gráficos com `grid`:

```{r, warning=FALSE}
both.1812.plot <- rbind(ggplotGrob(march.1812.plot),
                        ggplotGrob(temps.1812.plot), size="last")

grid::grid.newpage()
grid::grid.draw(both.1812.plot)
```

Os gráficos estão alinhados mas temos um problema com as proporções. Vamos resolver modificando manualmente os painéis.

```{r, fig.width=10, fig.height=5.5, warning=FALSE}
# Identificando os paneis do gráfico
panels <- both.1812.plot$layout$t[grep("panel", both.1812.plot$layout$name)]

map.panel.height <- both.1812.plot$heights[panels][1]

#Tive um problema convertendo o valor, então fiz o input manual.
map.panel.height <- list(0.345197879241894)

# Colocando os painéis no gráfico.
both.1812.plot$heights[panels] <- unit(c(map.panel.height, 0.1), "null")

grid::grid.newpage()
grid::grid.draw(both.1812.plot)
```

Vamos gerar agora um gráfico sem o mapa de fundo.

```{r, fig.width=10, fig.height=4.75, warning=FALSE}

march.1812.plot.simple <- ggplot() +
  geom_path(data = troops, aes(x = long, y = lat, group = group,
                               color = direction, size = survivors),
            lineend = "round") +
  geom_point(data = cities, aes(x = long, y = lat),
             color = "#DC5B44") +
  geom_text_repel(data = cities, aes(x = long, y = lat, label = city),
                  color = "#DC5B44") +
  scale_size(range = c(0.5, 10)) +
  scale_colour_manual(values = c("#DFC17E", "#252523")) +
  guides(color = FALSE, size = FALSE) +
  theme_nothing()

# Mudanças para que os eixos se coincidam sem o mapa.
temps.1812.plot <- ggplot(data = temps.nice, aes(x = long, y = temp)) +
  geom_line() +
  geom_label(aes(label = nice.label),
             size = 2.5) +
  labs(x = NULL, y = "° Celsius") +
  scale_x_continuous(limits = ggplot_build(march.1812.plot.simple)$layout$panel_ranges[[1]]$x.range) +
  scale_y_continuous(position = "right") +
  coord_cartesian(ylim = c(-35, 5)) +  # Add some space above/below
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks = element_blank(),
        panel.border = element_blank())

# Juntando os gráficos.
both.1812.plot.simple <- rbind(ggplotGrob(march.1812.plot.simple),
                               ggplotGrob(temps.1812.plot), size="last")

# Arrumando novamente a distribuição dos painéis.
panels <- both.1812.plot.simple$layout$t[grep("panel", both.1812.plot.simple$layout$name)]

both.1812.plot.simple$heights[panels] <- unit(c(3, 1), "null")

grid::grid.newpage()
grid::grid.draw(both.1812.plot.simple)
```

Pronto!

# Problema 3: Gapminder

Faça a animação presente em https://towardsdatascience.com/how-to-build-animated-charts-like-hans-rosling-doing-it-all-in-r-570efc6ba382 seguindo os passos lá descritos.

**Resposta:**

Vamos começar lendo os dados baixados.

```{r}
population_xls <- read.xlsx("./3/indicator gapminder population.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE)
fertility_xls <- read.xlsx("./3/indicator undata total_fertility.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE)
lifeexp_xls <- read.xlsx("./3/indicator life_expectancy_at_birth.xlsx", encoding = "UTF-8", stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE)
```

```{r}
# Create a variable to keep only years 1962 to 2015
myvars <- paste("X", 1962:2015, sep="")
# Create 3 data frame with only years 1962 to 2015
population <- population_xls[c('Total.population',myvars)]
fertility <- fertility_xls[c('Total.fertility.rate',myvars)]
lifeexp <- lifeexp_xls[c('Life.expectancy',myvars)]
# Rename the first column as "Country"
colnames(population)[1] <- "Country"
colnames(fertility)[1] <- "Country"
colnames(lifeexp)[1] <- "Country"
# Remove empty lines that were created keeping only 275 countries
lifeexp <- lifeexp[1:275,]
population <- population[1:275,]
# Use reshape library to move the year dimension as a column
population_m <- melt(population, id=c("Country"))
lifeexp_m <- melt(lifeexp, id=c("Country"))
fertility_m <- melt(fertility, id=c("Country"))
# Give a different name to each KPI (e.g. pop, life, fert)
colnames(population_m)[3] <- "pop"
colnames(lifeexp_m)[3] <- "life"
colnames(fertility_m)[3] <- "fert"
# Merge the 3 data frames into one
mydf <- merge(lifeexp_m, fertility_m, by=c("Country","variable"), header =T)
mydf <- merge(mydf, population_m, by=c("Country","variable"), header =T)
# The only piece of the puzzle missing is the continent name for each country for the color - use gapminder library to bring it
continent <- gapminder %>% group_by(continent, country) %>% distinct(country, continent)
continent <- data.frame(lapply(continent, as.character), stringsAsFactors=FALSE)
colnames(continent)[1] <- "Country"
# Filter out all countries that do not exist in the continent table
mydf_filter <- mydf %>% filter(Country %in% unique(continent$Country))
# Add the continent column to finalize the data set
mydf_filter <- merge(mydf_filter, continent, by=c("Country"), header =T)
# Do some extra cleaning (e.g. remove N/A lines, remove factors, and convert KPIs into numerical values)
mydf_filter[is.na(mydf_filter)] <- 0
mydf_filter <- data.frame(lapply(mydf_filter, as.character), stringsAsFactors=FALSE)
mydf_filter$variable <- as.integer(as.character(gsub("X","",mydf_filter$variable)))
colnames(mydf_filter)[colnames(mydf_filter)=="variable"] <- "year"
mydf_filter$pop <- round(as.numeric(as.character(mydf_filter$pop))/1000000,1)
mydf_filter$fert <- as.numeric(as.character(mydf_filter$fert))
mydf_filter$life <- as.numeric(as.character(mydf_filter$life))
```

```{r, warning=FALSE}
# Add a global theme
theme_set(theme_grey()+ theme(legend.box.background = element_rect(),legend.box.margin = margin(6, 6, 6, 6)) )
# OLD VERSION
# Create the plot with years as frame, limiting y axis from 30 years to 100
# p <- ggplot(mydf_filter, aes(fert, life, size = pop, color = continent, frame = variable)) +
#  geom_point()+ ylim(30,100)  + labs(x="Fertility Rate", y = "Life expectancy at birth (years)", caption = "(Based on data from Hans Rosling - gapminder.com)", color = 'Continent',size = "Population (millions)") +
#  scale_color_brewer(type = 'div', palette = 'Spectral')
# gganimate(p, interval = .2, "output.gif")
# NEW VERSION
# Create the plot with years as frame, limiting y axis from 30 years to 100
p <- ggplot(mydf_filter, aes(fert, life, size = pop, color = continent, frame = year)) +
  labs(x="Fertility Rate", y = "Life expectancy at birth (years)", caption = "(Based on data from Hans Rosling - gapminder.com)", color = 'Continent',size = "Population (millions)") +
  ylim(30,100) +
  geom_point() +
  scale_color_brewer(type = 'div', palette = 'Spectral') +
  # gganimate code
  ggtitle("Year: {frame_time}") +
  transition_time(year) +
  ease_aes("linear") +
  enter_fade() +
  exit_fade()
# animate
#animate(p, width = 450, height = 450)
animate(p, width = 900, height = 900, nframes = 100, fps = 8, end_pause = 32,renderer=gifski_renderer("save.gif"))
```

```{r, warning=FALSE, message=FALSE}
p <- ggplot(mydf_filter, aes(fert, life, size = pop, color = continent, frame = year)) +
  geom_point()+ ylim(30,100)  + labs(x="Fertility Rate", y = "Life expectancy at birth (years)", color = 'Continent',size = "Population (millions)") +
  scale_color_brewer(type = 'div', palette = 'Spectral')
# Generate the Visual and a HTML output
ggp <- ggplotly(p, height = 900, width = 900) %>%
  animation_opts(frame = 100,
                 easing = "linear",
                 redraw = FALSE)
ggp
htmlwidgets::saveWidget(ggp, "index.html")
```

# Problema 4: Atirei o pau no gráfico

Assista o vídeo https://www.youtube.com/watch?v=CJkzf4IZRuk em que o autor realiza um gráfico em Excel. Seguindo os mesmos passos, faça esse gráfico em R.

**Resposta:**

Vamos começar importando as tabelas.

```{r}
covid <- read.xlsx("./4/dados.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE)
covid <- data.frame(date = covid$data, obitos = covid$obitosAcumulado)
```

``````{r, fig.width=14, fig.height=9}
obitos <- covid$obitos
obitos <- obitos[obitos != 0]
obitos_help <- c(0 ,obitos)
obitos <- c(obitos, 0)

taxa <- obitos / obitos_help
taxa[taxa == Inf] <- 0

full <- cbind(data.frame(obitos, taxa)[-c(58),], date = ymd(covid$date[covid$obitos != 0]))

newdf <- full[full$date >= "2020-03-27",]



ylim.ob <- c(min(newdf$obitos), max(newdf$obitos))  
ylim.tax <- c(min(newdf$taxa), max(newdf$taxa))



unlog <- function(x) {
  sup <- c()
  for(i in x){
    sup <- c(sup, 10^i)
  }
  sup
}

newRange <- function(x, y) {
  oldMax <- max(x)
  oldMin <- min(x)
  newMax <- max(y)
  newMin <- min(y)
  oldValue <- x
  newValue <- 
    oldRange <-  (oldMax - oldMin)  
  newRange <-  (newMax - newMin)  
  newValue = (((oldValue - oldMin) * newRange) / oldRange) + newMin
}

newdf$taxa <- unlog(newdf$taxa)

newdf$taxa <- newRange(newdf$taxa, newdf$obitos)

colors <- c("Obitos" = "Blue", "Taxa" = "Orange")

ggplot(newdf, aes(x = date, y = obitos, color = "Obitos")) +
  geom_line(size = 2) +
  geom_point(size = 4) +
  geom_line(aes(y = taxa/10 + 10, color = "Taxa"), size = 2) +
  geom_point(aes(y = taxa/10 + 10, color = "Taxa"), size = 4) +
  scale_y_continuous(name = "Óbitos",trans = "log10", limits = c(1, 13000), breaks = c(1, 10, 100, 1000, 10000), sec.axis = sec_axis(~. / 100, name = "Taxa de crescimento", breaks = c(0.01, 0.0323, 0.1, 0.325, 1, 3.245, 10, 32.4, 100), labels = c(0.9, 0.95, 1, 1.05, 1.1, 1.15, 1.2, 1.25, 1.30))) +
  scale_x_date(name = 'Data', date_breaks = "1 day") +
  labs(color = "Legenda") +
  ggtitle("Óbitos COVID-19 no Brasil", ) +
  scale_color_manual(values = colors) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        legend.position="right") 
```

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

