---
title: 'Lista 5: Modificação da lista 4'
author: "João Vitor Freitas Sousa"
date: "25/05/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE,
                      fig.retina = 2,
                      tidy.opts=list(width.cutoff = 120),
                      options(width = 120, scipen = 1000))
library(tidyverse)
library(lubridate)
library(ggmap)
library(ggrepel)
library(gridExtra)
library(pander)
library(xlsx)
library(devtools)
library(RCurl)
library(httr)
library(reshape)
library(gapminder)
library(dplyr)
library(gganimate)
library(plotly)
library(gifski)
library(grid)
```

# Problema 1: The Economist

<!-- Crie o último gráfico do link [https://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html]. Este é um gráfico que apresenta uma relação entre o IDH x IPC entre diversos países. -->

<!-- **Resposta:** -->

<!-- Dados os conceitos passados nas últimas aulas, considerei válido alterar a escala de cor utilizando agora uma retirada do ColorBrewer com configurações divergentes. Considerei também retirar os países que estão sem as labels, visto que assim o gráfico fica menos poluído e aumenta a velocidade de interpretação do mesmo. -->

<!-- Primeiro então a importação dos dados e a manipulação. -->

<!-- ```{r, fig.width=14, fig.height=10, warning=FALSE, message=FALSE} -->
<!-- dat <- read_csv("./1/EconomistData.csv") -->
<!-- pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan", -->
<!--                    "Afghanistan", "Congo", "Greece", "Argentina", "Brazil", -->
<!--                    "India", "Italy", "China", "South Africa", "Spane", -->
<!--                    "Botswana", "Cape Verde", "Bhutan", "Rwanda", "France", -->
<!--                    "United States", "Germany", "Britain", "Barbados", "Norway", "Japan", -->
<!--                    "New Zealand", "Singapore") -->

<!-- dat <- dat[dat$Country %in% pointsToLabel,] # Filtro dos países -->

<!-- dat$Region <- factor(dat$Region, -->
<!--                      levels = c("EU W. Europe", -->
<!--                                 "Americas", -->
<!--                                 "Asia Pacific", -->
<!--                                 "East EU Cemt Asia", -->
<!--                                 "MENA", -->
<!--                                 "SSA"), -->
<!--                      labels = c("OECD", -->
<!--                                 "Americas", -->
<!--                                 "Asia &\nOceania", -->
<!--                                 "Central &\nEastern Europe", -->
<!--                                 "Middle East &\nnorth Africa", -->
<!--                                 "Sub-Saharan\nAfrica")) -->

<!-- mR2 <- summary(lm(HDI ~ CPI + log(CPI), data = dat))$r.squared -->
<!-- mR2 <- paste0(format(mR2, digits = 2), "%") -->
<!-- ``` -->

<!-- Aqui o código que gera o gráfico já com a nova paleta de cores. -->

<!-- ```{r fig.height=10, fig.width=14, message=FALSE, warning=FALSE} -->
<!-- newpalette <- c('#d73027','#fc8d59','#fee08b','#d9ef8b','#91cf60','#1a9850') -->
<!-- #newpalette <- c('#d53e4f','#fc8d59','#fee08b','#e6f598','#99d594','#3288bd') -->
<!-- p <- ggplot(dat, -->
<!--             mapping = aes(x = CPI, y = HDI)) + -->
<!--   geom_smooth(mapping = aes(linetype = "r2"), -->
<!--               method = "lm", -->
<!--               formula = y ~ x + log(x), se = FALSE, -->
<!--               color = "red") + -->
<!--   geom_point(mapping = aes(color = Region), -->
<!--              shape = 1, -->
<!--              size = 4, -->
<!--              stroke = 1.5) + -->
<!--   geom_text_repel(mapping = aes(label = Country), -->
<!--                   data = transform(dat,labels = Country), -->
<!--                   force = 4, -->
<!--                   direction = c("both")) + -->
<!--   scale_x_continuous(name = "Corruption Perception Index, 2011 (10=least corrupt)", -->
<!--                      limits = c(1.0, 10.0), -->
<!--                      breaks = 1:10) + -->
<!--   scale_y_continuous(name = "Human Development Index, 2011 (1=best)", -->
<!--                      limits = c(0.2, 1.0), -->
<!--                      breaks = seq(0.2, 1.0, by = 0.1)) + -->
<!--   scale_color_manual(name = "", -->
<!--                      values = newpalette, -->
<!--                      guide = guide_legend(nrow = 1, order=1)) + -->
<!--   scale_alpha_discrete(range = c(0, 1), -->
<!--                        guide = FALSE) + -->

<!--   scale_linetype(name = "", -->
<!--                  breaks = "r2", -->
<!--                  labels = list(bquote(R^2==.(mR2))), -->
<!--                  guide = guide_legend(override.aes = list(linetype = 1, size = 2, color = "red"), order=2)) + -->
<!--   ggtitle("Corruption and human development") + -->
<!--   labs(caption="Sources: Transparency International; UN Human Development Report") + -->
<!--   theme_bw() + -->
<!--   theme(panel.border = element_blank(), -->
<!--         panel.grid = element_blank(), -->
<!--         panel.grid.major.y = element_line(color = "gray"), -->
<!--         text = element_text(color = "black"), -->
<!--         axis.title.x = element_text(face="italic"), -->
<!--         axis.title.y = element_text(face="italic"), -->
<!--         legend.position = "top", -->
<!--         legend.direction = "horizontal", -->
<!--         legend.box = "horizontal", -->
<!--         legend.text = element_text(size = 12), -->
<!--         plot.caption = element_text(hjust=0), -->
<!--         plot.title = element_text(size = 16, face = "bold")) -->
<!-- p -->
<!-- ``` -->

# Problema 2: Minard

<!-- Reproduza o gráfico de Minard que representa a jornada do lider político Napoleão ao levar seu exército para a Campanha Russa. O tutorial se encontra em [https://www.andrewheiss.com/blog/2017/08/10/exploring-minards-1812-plot-with-ggplot2/]. -->

<!-- **Resposta:** -->

<!-- ```{r} -->
<!-- # Importando os dados baixados e já transformando as datas para o formato padrão do R. -->
<!-- cities <- read.table("./2/cities.txt", -->
<!--                      header = TRUE, stringsAsFactors = FALSE) -->

<!-- troops <- read.table("./2/troops.txt", -->
<!--                      header = TRUE, stringsAsFactors = FALSE) -->

<!-- temps <- read.table("./2/temps.txt", -->
<!--                     header = TRUE, stringsAsFactors = FALSE) %>% -->
<!--   mutate(date = dmy(date)) -->
<!-- ``` -->

<!-- ```{r, fig.width=10, fig.height=4, warning=FALSE} -->
<!-- # Melhorando as labels. -->
<!-- temps.nice <- temps %>% -->
<!--   mutate(nice.label = paste0(temp, "°, ", month, ". ", day)) -->
<!-- ``` -->

<!-- Gráfico: -->

<!-- ```{r, fig.width=10, fig.height=4.75, warning=FALSE} -->

<!-- march.1812.plot.simple <- ggplot() + -->
<!--   geom_path(data = troops, aes(x = long, y = lat, group = group, -->
<!--                                color = direction, size = survivors), -->
<!--             lineend = "round") + -->
<!--   geom_point(data = cities, aes(x = long, y = lat), -->
<!--              color = "black") + -->
<!--   geom_text_repel(data = cities, aes(x = long, y = lat, label = city), -->
<!--                   color = "black", -->
<!--                   force = 10) + -->
<!--   scale_size(range = c(0.5, 10)) + -->
<!--   scale_colour_manual(values = c("#d8b365", "#ca0020")) + -->
<!--   guides(color = FALSE, size = FALSE) + -->
<!--   theme_nothing() -->

<!-- # Mudanças para que os eixos se coincidam sem o mapa. -->
<!-- temps.1812.plot <- ggplot(data = temps.nice, aes(x = long, y = temp)) + -->
<!--   geom_line() + -->
<!--   geom_label(aes(label = nice.label), -->
<!--              size = 2.5) + -->
<!--   labs(x = NULL, y = "° Celsius") + -->
<!--   scale_x_continuous(limits = ggplot_build(march.1812.plot.simple)$layout$panel_ranges[[1]]$x.range) + -->
<!--   scale_y_continuous(position = "right") + -->
<!--   coord_cartesian(ylim = c(-35, 5)) +  # Add some space above/below -->
<!--   theme(panel.grid.major.x = element_blank(), -->
<!--         panel.grid.minor.x = element_blank(), -->
<!--         panel.grid.minor.y = element_blank(), -->
<!--         axis.text.x = element_blank(), axis.ticks = element_blank(), -->
<!--         panel.border = element_blank()) -->

<!-- # Juntando os gráficos. -->
<!-- both.1812.plot.simple <- rbind(ggplotGrob(march.1812.plot.simple), -->
<!--                                ggplotGrob(temps.1812.plot), size="last") -->

<!-- # Arrumando novamente a distribuição dos painéis. -->
<!-- panels <- both.1812.plot.simple$layout$t[grep("panel", both.1812.plot.simple$layout$name)] -->

<!-- both.1812.plot.simple$heights[panels] <- unit(c(3, 1), "null") -->

<!-- grid::grid.newpage() -->
<!-- grid::grid.draw(both.1812.plot.simple) -->
<!-- ``` -->

<!-- Pronto! -->

# Problema 3: Gapminder

<!-- Faça a animação presente em [https://towardsdatascience.com/how-to-build-animated-charts-like-hans-rosling-doing-it-all-in-r-570efc6ba382] seguindo os passos lá descritos. -->

<!-- **Resposta:** -->

<!-- Vamos começar lendo os dados baixados. -->

<!-- ```{r, warning=FALSE} -->
<!-- population_xls <- read.xlsx("./3/indicator gapminder population.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE) -->
<!-- fertility_xls <- read.xlsx("./3/indicator undata total_fertility.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE) -->
<!-- lifeexp_xls <- read.xlsx("./3/indicator life_expectancy_at_birth.xlsx", encoding = "UTF-8",stringsAsFactors= F, sheetIndex = 1, as.data.frame = TRUE, header=TRUE) -->
<!-- ``` -->

<!-- Como os scripts passados são muito grandes, irei comentar sua execução dentro do código. -->
<!-- Primeira parte, a manipulação dos dados. -->

<!-- ```{r} -->
<!-- # Cria uma variável que será usada para filtrar os dados nas linhas a seguir -->
<!-- myvars <- paste("X", 1962:2015, sep="") -->
<!-- # Gera novos dataframes somente com os anos desejados. -->
<!-- population <- population_xls[c('Total.population',myvars)] -->
<!-- fertility <- fertility_xls[c('Total.fertility.rate',myvars)] -->
<!-- lifeexp <- lifeexp_xls[c('Life.expectancy',myvars)] -->
<!-- # Renomeia a primeira coluna dos dataframes com "Country" -->
<!-- colnames(population)[1] <- "Country" -->
<!-- colnames(fertility)[1] <- "Country" -->
<!-- colnames(lifeexp)[1] <- "Country" -->
<!-- # Remove linhas vazias no final do dataframe -->
<!-- lifeexp <- lifeexp[1:275,] -->
<!-- population <- population[1:275,] -->
<!-- # Transforma os dataframes trazendo os anos como coluna -->
<!-- population_m <- melt(population, id=c("Country")) -->
<!-- lifeexp_m <- melt(lifeexp, id=c("Country")) -->
<!-- fertility_m <- melt(fertility, id=c("Country")) -->
<!-- # Renomeia a coluna que mantem os dados -->
<!-- colnames(population_m)[3] <- "pop" -->
<!-- colnames(lifeexp_m)[3] <- "life" -->
<!-- colnames(fertility_m)[3] <- "fert" -->
<!-- # Unifica os dataframes -->
<!-- mydf <- merge(lifeexp_m, fertility_m, by=c("Country","variable"), header =T) -->
<!-- mydf <- merge(mydf, population_m, by=c("Country","variable"), header =T) -->
<!-- # Usando o gapminder para criar um lista com os continentes de cada país do dataframe -->
<!-- continent <- gapminder %>% group_by(continent, country) %>% distinct(country, continent) -->
<!-- continent <- data.frame(lapply(continent, as.character), stringsAsFactors=FALSE) -->
<!-- colnames(continent)[1] <- "Country" -->
<!-- # Retira os paises que não estão presentes na tabela de continentes -->
<!-- mydf_filter <- mydf %>% filter(Country %in% unique(continent$Country)) -->
<!-- # E finalmente adiciona a coluna continentes ao dataframe -->
<!-- mydf_filter <- merge(mydf_filter, continent, by=c("Country"), header =T) -->
<!-- #Remove as linhas com valores "N/A", retorna as strings para o formato "character" e converte os dados para o formato numérico. -->
<!-- mydf_filter[is.na(mydf_filter)] <- 0 -->
<!-- mydf_filter <- data.frame(lapply(mydf_filter, as.character), stringsAsFactors=FALSE) -->
<!-- mydf_filter$variable <- as.integer(as.character(gsub("X","",mydf_filter$variable))) -->
<!-- colnames(mydf_filter)[colnames(mydf_filter)=="variable"] <- "year" -->
<!-- mydf_filter$pop <- round(as.numeric(as.character(mydf_filter$pop))/1000000,1) -->
<!-- mydf_filter$fert <- as.numeric(as.character(mydf_filter$fert)) -->
<!-- mydf_filter$life <- as.numeric(as.character(mydf_filter$life)) -->
<!-- ``` -->
<!-- Segunda parte, a criação do gráfico com o ggplot: -->
<!-- ```{r, warning=FALSE} -->
<!-- # Criação de um tema global para o ggplot -->
<!-- theme_set(theme_grey()+ theme(legend.box.background = element_rect(),legend.box.margin = margin(6, 6, 6, 6)) ) -->
<!-- # Cria um gráfico com o ano como frame , eixo x sendo a taxa de fertilidade, eixo y sendo a expectativa de vida e o tamanho dos pontos sendo o tamanho da população. Há também ajustes gráficos, como a configuração dos limites do eixo y. -->
<!-- p <- ggplot(mydf_filter, aes(fert, life, size = pop, color = continent, frame = year)) + -->
<!--   labs(x="Fertility Rate", y = "Life expectancy at birth (years)", caption = "(Based on data from Hans Rosling - gapminder.com)", color = 'Continent',size = "Population (millions)") + -->
<!--   ylim(30,100) + -->
<!--   geom_point() + -->
<!--   scale_color_brewer(type = 'div', palette = 'Spectral') + -->
<!--   # Criação da animação definindo título, a unidade que determinara a transição de frames e a forma como será feita(linear). -->
<!--   ggtitle("Year: {frame_time}") + -->
<!--   transition_time(year) + -->
<!--   ease_aes("linear") + -->
<!--   enter_fade() + -->
<!--   exit_fade() -->
<!-- # Comando que gera a animação. -->
<!-- animate(p, width = 900, height = 900, nframes = 100, fps = 8, end_pause = 32,renderer=gifski_renderer("save.gif")) -->
<!-- ``` -->

<!-- Agora criando o gráfico interativo com o `plotly`. -->

<!-- ```{r, warning=FALSE, message=FALSE} -->
<!-- # A estrutura do gráfico é feita em ggplot, assim como no chunk acima -->
<!-- p <- ggplot(mydf_filter, aes(fert, life, size = pop, color = continent, frame = year)) + -->
<!--   geom_point()+ ylim(30,100)  + labs(x="Fertility Rate", y = "Life expectancy at birth (years)", color = 'Continent',size = "Population (millions)") + -->
<!--   scale_color_brewer(type = 'div', palette = 'Spectral') -->

<!-- # Utilizando o gráfico gerado acima, cria o interativo -->

<!-- ggp <- ggplotly(p, height = 900, width = 900) %>% -->
<!--   animation_opts(frame = 100, -->
<!--                  easing = "linear", -->
<!--                  redraw = FALSE) -->
<!-- ggp -->
<!-- htmlwidgets::saveWidget(ggp, "index.html") -->
<!-- ``` -->

# Problema 4: Atirei o pau no gráfico

<!-- Assista o vídeo [https://www.youtube.com/watch?v=CJkzf4IZRuk] em que o autor realiza um gráfico em Excel. Seguindo os mesmos passos, faça esse gráfico em R. -->

<!-- **Resposta:** -->

<!-- Mantive o gráfico alterando somente o período representado. -->

<!-- ```{r, warning=FALSE, error=FALSE, eval = FALSE} -->
<!-- covid <- read_csv("./4/dados1.csv") -->
<!-- covid <- data.frame(date = covid$data, obitos = covid$Obitos) -->
<!-- ``` -->

<!-- ```{r, warning = FALSE, message= FALSE, eval=FALSE} -->
<!-- # Aqui é feita a remoção das linhas cujos número de óbitos é 0 e a criação de um vetor que auxiliará no cálculo da taxa. -->
<!-- obitos <- covid$obitos -->
<!-- obitos <- obitos[obitos != 0] -->
<!-- obitos_help <- c(0 ,obitos) -->
<!-- obitos <- c(obitos, 0) -->
<!-- # Cálculo da taxa -->
<!-- taxa <- obitos / obitos_help -->
<!-- taxa[taxa == Inf] <- 0 -->
<!-- # Criação de um dataframe com as datas, os óbitos e as taxas já calculadas. -->
<!-- full <- cbind(data.frame(obitos, taxa)[-c(59),], date = ymd(covid$date[covid$obitos != 0])) -->
<!-- # Filtragem desse dataframe para as datas utilizadas no video. -->
<!-- newdf <- full[full$taxa != 0] -->
<!-- # Criação dos estilos a serem utilizados no gráfico, as listas a seguir dizem respeito respectivamente ao eixo principal(em escala logarítmica) que está ligado aos óbitos e ao eixo secundário(em escala linear) que está ligado a taxa de crescimento. -->
<!-- style.atirei1y1 <- list( -->
<!--   autotick = FALSE, -->
<!--   type = "log", # Transforma o eixo para a escala logarítmica -->
<!--   ticks = "outside", -->
<!--   tick0 = 10, -->
<!--   tickwidth = 2, -->
<!--   tickcolor = toRGB("blue"), -->
<!--   title = "" -->
<!-- ) -->
<!-- style.atirei1y2 <- list( -->
<!--   autotick = FALSE, -->
<!--   ticks = "outside", -->
<!--   tick0 = 0.8, -->
<!--   dtick = 0.05, -->
<!--   ticklen = 1.5, -->
<!--   tickwidth = 1, -->
<!--   tickcolor = toRGB("blue"), -->
<!--   side = "right", -->
<!--   overlaying = "y" -->
<!-- ) -->
<!-- # Utilizando o plotly, defini um gráfico com eixo x sendo as datas. -->
<!-- atirei1 <- plot_ly(x = ~newdf$date) -->
<!-- # Adicionando a linha de óbitos. -->
<!-- atirei1 <- atirei1 %>% add_trace(y = ~newdf$obitos, name = "Óbitos", mode = "lines+markers", line = list(shape = "spline", width = 2)) -->
<!-- # Adicionando a linha de taxa de crescimento e a ligando ao eixo secundário(yaxis = "y2"), assim a mesma se manterá em escala linear -->
<!-- atirei1 <- atirei1 %>% add_trace(y =  ~newdf$taxa, name = "Taxa de crescimento", mode = "lines+markers", line = list(width = 2), yaxis = "y2") -->
<!-- # Aplicação dos estilos citados acima, adição do título, movimentação da legenda para a parte inferior. -->
<!-- atirei1 <- atirei1 %>% layout(xaxis = list(title = ""),yaxis = style.atirei1y1, yaxis2 = style.atirei1y2, title = "Óbitos COVID-19 no Brasil",legend = list(orientation = "h"), margin = list(r = 50)) -->
<!-- # Exibição do gráfico -->
<!-- atirei1 -->
<!-- ``` -->

<!-- Na segunda parte vou fazer alterações na parte de manipulação e previsão de óbitos futuros. -->
<!-- Na tabela de previsão: -->

<!-- ```{r, warning = FALSE, message= FALSE, eval=FALSE} -->
<!-- # Função para gerar a previsão dos óbitos com base em taxas de crescimento aleatórias geradas a partir da função runif() que gera essas taxas em um determinado intervalo. -->
<!-- simulacrescimento <- function(taxa, valor_inicial, dias){ -->
<!--   sup <- c(valor_inicial) -->
<!--   for(i in 1:dias){ -->
<!--     sup <- c(sup, round(tail(sup, 1) * taxa[i])) -->
<!--   } -->
<!--   sup -->
<!-- } -->
<!-- # Preparando as datas a serem adicionadas no dataframe(restante do mês de abril) -->
<!-- newdates <- seq(as.Date("2020-05-24"), as.Date("2020-06-30"), by="days") -->
<!-- newdates <- c(newdf$date, newdates) -->
<!-- # Contagem dos dias que foram adicionados -->
<!-- diasadicionados <- length(newdates) - length(newdf$date) -->
<!-- # Preparando as taxas a serem adicionadas no dataframe(pegando valores aleatórios dentre o intervalo determinado. O porquê desse intervalo será explicado no final do documento) -->
<!-- taxa <-  runif(diasadicionados, min = 1.02, max = 1.038) -->
<!-- newtaxa <- c(newdf$taxa, taxa) -->
<!-- # Criação do vetor com os óbitos já registrados e com a previsão. -->
<!-- newobitos <- c(newdf$obitos, simulacrescimento(taxa, tail(newdf$obitos, n = 1), diasadicionados)[-39]) -->
<!-- # União das novas unidades em um dataframe. -->
<!-- tabela <- data.frame(Data = newdates, obitos = newobitos, taxa = newtaxa) -->

<!-- knitr::kable(tabela) -->

<!-- atirei1 <- plot_ly(x = ~tabela$Data) -->
<!-- # Adicionando a linha de óbitos. -->
<!-- atirei1 <- atirei1 %>% add_trace(y = ~tabela$obitos, name = "Óbitos", mode = "lines+markers", line = list(color = "#00868A", shape = "spline", width = 2)) -->
<!-- # Adicionando a linha de taxa de crescimento e a ligando ao eixo secundário(yaxis = "y2"), assim a mesma se manterá em escala linear -->
<!-- atirei1 <- atirei1 %>% add_trace(y =  ~tabela$taxa, name = "Taxa de crescimento", mode = "lines+markers", line = list(color = "#FF7119",width = 2),yaxis = "y2") -->
<!-- # Aplicação dos estilos citados acima, adição do título, movimentação da legenda para a parte inferior. -->
<!-- atirei1 <- atirei1 %>% layout(xaxis = list(title = ""),yaxis = style.atirei1y1, yaxis2 = style.atirei1y2, title = paste("Obitos COVID-19 no Brasil Previsão até 06/2020 com taxa constante de ", round(media, digits = 3)),legend = list(orientation = "h"), margin = list(r = 50)) -->
<!-- # Exibição do gráfico -->
<!-- atirei1 -->
<!-- ``` -->

<!-- ## O porquê do intervalo para a previsão -->

<!-- Com o que foi observado nas taxas do últimos 10 dias, variando de 1.031 a 1.070, estimei um máximo dessa taxa em 1.038 e o mínimo de 1.020 visto que a taxa tende a diminuir como vemos no primeiro gráfico. Uma vez que os valores que obtive em múltiplas execuções do código ficaram com a média em torno dos 60 mil projetados pelo IHME(Instituto de Métrica da Universidade de Washington, nos Estados Unidos) e por outros estudos e segue a média de mil óbitos que estamos tendo por dia, acredito que essa forma de variar a taxa seja válida e uma alternativa a manter uma taxa fixa. Uma forma maximizar a precisão dessa previsão talvez fosse rodar o código múltiplas vezes e usar como valores as médias. Outras seria gerar um modelo para prever as taxas baseado nas taxas que tivemos anteriormente. -->